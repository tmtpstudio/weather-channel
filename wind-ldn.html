<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wind Flow Field</title>

  <!-- p5.js -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #f0f0f0;
    }
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 0;
    }
  </style>

  <!--
    Credits:
    Art Direction by TMTP
    Developed & written with ChatGPT
    Edited with Lumo
  -->
</head>

<body>
<script>
// ------------------------------------------------------------
// Wind Flow Field – London only
// Data sources: Open‑Meteo (weather) & WorldTimeAPI (clock)
// ------------------------------------------------------------

// ----- Global state -------------------------------------------------
let windSpeed = 0;          // m/s
let windDir   = 0;          // degrees
let hasWindData = false;
let lastFetch = 0;
const fetchInterval = 60000; // 1 min

let globalTime = "";        // ISO timestamp from WorldTimeAPI
let agents = [];            // collection of LineAgent objects
const numLines = 300;
const speedScale = 0.3;

// London coordinates
const lat = 51.5074;
const lon = -0.1278;

// ------------------------------------------------------------
function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);
  textFont('Andale Mono, monospace');
  textSize(11);
  textAlign(LEFT, BOTTOM);
  fill(0);

  // initialise agents
  for (let i = 0; i < numLines; i++) {
    agents.push(new LineAgent(random(width), random(height)));
  }

  // immediate data fetch
  fetchData();
  fetchTime();
  lastFetch = millis();
}

// ------------------------------------------------------------
function draw() {
  background(240);

  if (hasWindData && windSpeed > 0.01) {
    const globalLen = constrain(map(windSpeed, 0, 30, 0, 300), 0, 300);
    const baseAngle = radians(windDir + 90);
    const vx = cos(baseAngle) * windSpeed * 0.25 * speedScale;
    const vy = sin(baseAngle) * windSpeed * 0.25 * speedScale;

    // number of agents actually drawn – scales with wind speed
    const effectiveNum = constrain(int(map(windSpeed, 0, 33, 7, 251)), 7, 251);

    // colour ramp: black → yellow → red
    let col;
    if (windSpeed < 20) {
      col = color(0, 0, 0);               // black (RGB mode)
    } else {
      // map 20‑30 m/s → hue 60 (yellow) → 0 (red)
      const hue = map(constrain(windSpeed, 20, 30), 20, 30, 60, 0);
      colorMode(HSB, 360, 100, 100);
      col = color(hue, 100, 100);
      colorMode(RGB, 255);                // restore default for other drawing
    }

    for (let i = 0; i < effectiveNum; i++) {
      const a = agents[i];
      a.update(vx, vy, baseAngle, globalLen);
      a.display(baseAngle, globalLen, col);
    }
  } else {
    // fallback – static points when no wind data
    stroke(200, 0, 0);
    strokeWeight(0.5);
    for (const a of agents) point(a.x, a.y);
  }

  drawInfoStrip();

  // refresh data each minute
  if (millis() - lastFetch > fetchInterval) {
    fetchData();
    fetchTime();
    lastFetch = millis();
  }
}

// ------------------------------------------------------------
function drawInfoStrip() {
  if (!globalTime) return;

  const d = new Date(globalTime);
  const hh = nf(d.getHours(), 2);
  const mm = nf(d.getMinutes(), 2);
  const days = ['SUN','MON','TUE','WED','THU','FRI','SAT'];
  const months = ['01','02','03','04','05','06','07','08','09','10','11','12'];

  const dayName = days[d.getDay()];
  const dd = nf(d.getDate(), 2);
  const MM = months[d.getMonth()];
  const yyyy = d.getFullYear();

  const label = `LDN WIND ${dayName} ${dd}-${MM}-${yyyy} ${hh}${mm}`;
  noStroke();
  fill(0);
  text(label, 5, height - 3);

  // flashing underscore after minutes
  if (frameCount % 60 < 30) {
    const prefix = `WIND LDN ${dayName} ${dd}-${MM}-${yyyy} ${hh}`;
    const w = textWidth(prefix);
    text('_', 5 + w, height - 3);
  }
}

// ------------------------------------------------------------
class LineAgent {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.phase = random(TWO_PI);
    this.freq = random(0.01, 0.05);
    this.amp = random(0.02, 0.05);
    this.angleOffset = radians(random(-2, 2));
    this.lengthFactor = random(0.7, 1.3);
    this.growth = 0;
    this.growthRate = random(0.002, 0.01);
  }

  update(vx, vy, baseAngle, len) {
    this.growth = min(1, this.growth + this.growthRate);

    const jitterX = cos(frameCount * this.freq + this.phase) * this.amp * vx;
    const jitterY = sin(frameCount * this.freq + this.phase) * this.amp * vy;

    this.x += vx + jitterX;
    this.y += vy + jitterY;

    // wrap around when leaving the canvas (+/- len buffer)
    if (this.x < -len || this.x > width + len ||
        this.y < -len || this.y > height + len) {
      const edge = int(random(4));
      if (edge === 0) { this.x = -len; this.y = random(height); }
      else if (edge === 1) { this.x = width + len; this.y = random(height); }
      else if (edge === 2) { this.x = random(width); this.y = -len; }
      else { this.x = random(width); this.y = height + len; }
    }
  }

  display(baseAngle, globalLen, col) {
    const targetLen = globalLen * this.lengthFactor;
    const thisLen = lerp(2, targetLen, this.growth);
    push();
    translate(this.x, this.y);
    rotate(baseAngle + this.angleOffset);
    stroke(col);
    strokeWeight(0.5);
    line(-thisLen / 2, 0, thisLen / 2, 0);
    pop();
  }
}

// ------------------------------------------------------------
// Async data fetchers
async function fetchData() {
  try {
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true`;
    const res = await fetch(url);
    const data = await res.json();
    if (data?.current_weather) {
      windSpeed = data.current_weather.windspeed;
      windDir   = data.current_weather.winddirection;
      hasWindData = true;
      console.log('Wind updated:', windSpeed, 'm/s', windDir + '°');
    }
  } catch (e) {
    console.warn('Weather fetch failed:', e);
    hasWindData = false;
  }
}

async function fetchTime() {
  try {
    const res = await fetch('https://worldtimeapi.org/api/timezone/Europe/London');
    const data = await res.json();
    globalTime = data.datetime; // ISO timestamp
    console.log('Time updated:', globalTime);
  } catch (e) {
    console.warn('Time fetch failed:', e);
  }
}

// ------------------------------------------------------------
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
