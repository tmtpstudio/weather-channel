<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wind Flow Field</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <style>
    body { margin:0; padding:0; overflow:hidden; background:#f0f0f0; }
    canvas { display:block; position:fixed; top:0; left:0; z-index:0; }
  </style>
</head>
<body>
<script>
// Wind Flow Field (London only)
// Wind data: Open-Meteo
// Clock: WorldTimeAPI
// Code evolved with ChatGPT ✨

let windSpeed = 0;
let windDir = 0;
let hasWindData = false;
let lastFetch = 0;
let fetchInterval = 60000; // 1 minute

let globalTime = ""; // authoritative London time

let agents = [];
let numLines = 300;
let speedScale = 0.3;

// London coordinates
let lat = 51.5074;
let lon = -0.1278;

function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);
  textFont("Andale Mono, monospace");
  textSize(11);
  textAlign(LEFT, BOTTOM);
  fill(0);

  for (let i = 0; i < numLines; i++) {
    agents.push(new LineAgent(random(width), random(height)));
  }

  // Fetch data + clock immediately
  fetchData();
  fetchTime();
  lastFetch = millis();
}

function draw() {
  background(240);

  if (hasWindData && windSpeed > 0.01) {
    let globalLen = map(windSpeed, 0, 30, 0, 300);
    globalLen = constrain(globalLen, 0, 300);

    let baseAngle = radians(windDir + 90);
    let vx = cos(baseAngle) * windSpeed * 0.25 * speedScale;
    let vy = sin(baseAngle) * windSpeed * 0.25 * speedScale;

    let effectiveNum = int(map(windSpeed, 0, 33, 7, 251));
    effectiveNum = constrain(effectiveNum, 7, 251);

    let col = (windSpeed >= 20) ? color(200, 0, 0) : color(0);

    for (let i = 0; i < effectiveNum; i++) {
      let a = agents[i];
      a.update(vx, vy, baseAngle, globalLen);
      a.display(baseAngle, globalLen, col);
    }
  } else {
    stroke(200, 0, 0);
    strokeWeight(0.5);
    for (let a of agents) {
      point(a.x, a.y);
    }
  }

  // --- Info strip with flashing underscore ---
  drawInfoStrip();

  // Refresh weather + clock every minute
  if (millis() - lastFetch > fetchInterval) {
    fetchData();
    fetchTime();
    lastFetch = millis();
  }
}

function drawInfoStrip() {
  if (globalTime !== "") {
    let d = new Date(globalTime);

    let hh = nf(d.getHours(), 2);
    let mm = nf(d.getMinutes(), 2);

    let days = ["SUN","MON","TUE","WED","THU","FRI","SAT"];
    let months = ["01","02","03","04","05","06","07","08","09","10","11","12"];

    let dayName = days[d.getDay()];
    let dd = nf(d.getDate(), 2);
    let MM = months[d.getMonth()];
    let yyyy = d.getFullYear();

    let label = `LDN  ${dayName}  ${dd}-${MM}-${yyyy} ${hh}${mm}`;
    noStroke();
    fill(0);
    text(label, 5, height - 3);

    // Flashing underscore after minutes
    if (frameCount % 60 < 30) {
      let prefix = `LDN  ${dayName}  ${dd}-${MM}-${yyyy} ${hh}`;
      let w = textWidth(prefix);
      let x = 5 + w;
      let y = height - 3;
      text("_", x, y);
    }
  }
}

class LineAgent {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.phase = random(TWO_PI);
    this.freq = random(0.01, 0.05);
    this.amp = random(0.02, 0.05);
    this.angleOffset = radians(random(-2, 2));
    this.lengthFactor = random(0.7, 1.3);

    this.growth = 0;
    this.growthRate = random(0.002, 0.01);
  }

  update(vx, vy, baseAngle, len) {
    this.growth = min(1, this.growth + this.growthRate);

    let jitterX = cos(frameCount * this.freq + this.phase) * this.amp * vx;
    let jitterY = sin(frameCount * this.freq + this.phase) * this.amp * vy;
    this.x += vx + jitterX;
    this.y += vy + jitterY;

    if (this.x < -len || this.x > width + len || this.y < -len || this.y > height + len) {
      let edge = int(random(4));
      if (edge === 0) { this.x = -len; this.y = random(height); }
      else if (edge === 1) { this.x = width + len; this.y = random(height); }
      else if (edge === 2) { this.x = random(width); this.y = -len; }
      else if (edge === 3) { this.x = random(width); this.y = height + len; }
    }
  }

  display(baseAngle, globalLen, col) {
    let targetLen = globalLen * this.lengthFactor;
    let thisLen = lerp(2, targetLen, this.growth);

    push();
    translate(this.x, this.y);
    rotate(baseAngle + this.angleOffset);
    stroke(col);
    strokeWeight(0.5);
    line(-thisLen / 2, 0, thisLen / 2, 0);
    pop();
  }
}

// --- Fetch functions ---

async function fetchData() {
  try {
    let url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true`;
    let res = await fetch(url);
    let data = await res.json();
    if (data && data.current_weather) {
      windSpeed = data.current_weather.windspeed;
      windDir = data.current_weather.winddirection;
      hasWindData = true;
      console.log("Wind updated:", windSpeed, "m/s", windDir + "°");
    }
  } catch (e) {
    console.warn("Weather fetch failed:", e);
    hasWindData = false;
  }
}

async function fetchTime() {
  try {
    let res = await fetch("https://worldtimeapi.org/api/timezone/Europe/London");
    let data = await res.json();
    globalTime = data.datetime; // authoritative ISO timestamp
    console.log("Time updated:", globalTime);
  } catch (e) {
    console.warn("Time fetch failed:", e);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
